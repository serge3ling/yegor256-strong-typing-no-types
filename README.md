## Строга типізація без типів

(Оригінал цієї статті знаходиться [тут](https://www.yegor256.com/2020/11/10/typing-without-types.html).)

10 листопада 2020 р. Москва, Росія.

Автор: [Єгор Бугаєнко](https://www.yegor256.com).

В 1974 році Лісков (Liskov) і Зилес (Zilles) [дали визначення](https://dl.acm.org/doi/abs/10.1145/942572.807045) мови зі [строгою типізацією](https://en.wikipedia.org/wiki/Strong_and_weak_typing) як такої, в якій "кожного разу, коли об'єкт передається від викликаючої функції до викликуваної, його тип мусить бути сумісним із типом, оголошеним у викликуваній функції". Строга [перевірка типів](https://en.wikipedia.org/wiki/Type_system), поза сумнівом, зменшує кількість [помилок, пов'язаних із типами](https://en.wikipedia.org/wiki/Type_system#Type_errors), а це підвищує якість. Однак є питання: чи нам потрібно вказувати типи, щоб отримати строгу типізацію?

![Redirected](/redirected.jpg)
(Image :copyright: Redirected (2014) by Emilis Velyvis)

Наприклад, тут ми очікуємо, що нам передадуть примірник Java-[інтерфейсу](https://docs.oracle.com/javase/tutorial/java/concepts/interface.html) `Book`:

```java
void print(Book b) {
  System.out.printf(
    "The ISBN is: %s%n", b.isbn()
  );
}
```

Тип `Book` може виглядати так:

```java
interface Book {
  String isbn();
}
```

Якщо об'єкт, який не імплементує інтерфейсу `Book`, передається в метод `print()`, компілятор викине помилку про неузгодження типів (type mismatch). Програмісту важко зробити помилку і передати об'єкт типу, скажімо, `Car` в метод `print()`. І все-таки це можливо при використанні динамічного приведення типів:

```java
Car car = new Car("Mercedes-Benz G63");
print(Book.class.cast(car)); // Отут!
```

Цей код компілюється без помилок, але в час виконання ми отримаємо [виняток `ClassCastException`](https://docs.oracle.com/javase/7/docs/api/java/lang/ClassCastException.html), бо неможливо привести `Car` до типу `Book`.

Краса строгої типізації в тому, що вона запобігає помилкам. Але вона також ускладнює код: спочатку ви маєте створити типи, ви маєте оголосити їх у всіх своїх функціях, вам потрібне приведення типів, а його важко зневадити, і так далі. [Захисники](https://softwareengineering.stackexchange.com/questions/38002) слабкої типізації дуже на це скаржаться і винаходять мови, подібні до Ruby, наприклад:

```ruby
def print(b)
  puts(format("This is ISBN: %s", b.isbn))
end
```

Тут функція `print()` не очікує якогось визначеного типу змінної `b`. Що їй не дай — все добре. Потім, коли настає час викликати `.isbn`, середовище виконання перевіряє, чи `b` має такий метод. Якщо має, все в порядку; якщо ні — видається [помилка часу виконання NoMethodError](https://ruby-doc.org/core-2.5.0/NoMethodError.html).

І ніби все добре.

Але є ідея: а якби ми поєднали простоту і стислість динамічної типізації з безпечністю строгої типізації, викинувши типи зовсім і дозволивши компілятору самому вгадати інформацію про типи з коду, який вживає відповідні об'єкти? Ось наш код знову:

```java
void print(Book b) {
  System.out.printf(
    "The ISBN is: %s%n", b.isbn()
  );
}
```

Подумайте над таким: в час компіляції вже майже очевидно, що `b` мусить мати *щонайменше* один метод — метод `isbn()`. Нема потреби вимагати від програміста визначити тип `Book` і явно вказати в сигнатурі методу `print()`, що ми дозволяємо тільки "книжкові" об'єкти: це легко вгадати, побачивши тіло методу `print()`! Компілятор може поглянути на всі твердження в методі `print()` і чітко *зрозуміти*, що саме має бути зроблено з об'єктом `b`. Цих відомостей повинно вистачити, щоб уявити "тип" об'єкту на вході. Нема потреби просити програміста вказати це явно і додати п'ять рядків коду в новому файлі для визначення типу `Book`. Компілятор може це зробити замість нас.

Звичайно, щоб це впровадити, ми мусимо заборонити будь-яке [приведення типів](https://www.yegor256.com/2015/04/02/class-casting-is-anti-pattern.html), а це неможливо в Java, C++, C# та інших псевдо-об'єктно-орієнтованих мовах. Але це можливо в [EO](https://www.eolang.org/)!

Що скажете?
